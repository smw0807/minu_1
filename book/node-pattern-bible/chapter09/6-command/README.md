# 6-6 명령 패턴

Node.js에서 매우 중요한 또 하나의 디자인 패턴은 명령(Cammand) 패턴이다.  
가장 일반적인 정의로는 실행에 필요한 모든 정보들을 캡슐화하고 이렇게 만든 모든 객체를 명령이라고 할 수 있다.  
따라서 함수나 기능을 직접적으로 호출하는 대신 이러한 호출을 수행하려는 의도를 나타내는 객체를 만든다.  
그런 다음 의도를 구체화하여 실제 작업으로 변환하는 것은 다른 컴포넌트가 담당한다.

![명령 패턴의 컴포넌트들](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc261f43-de91-483d-8946-ac5a65106576/2b862937-3d99-447d-9792-ca6a7235199e/Untitled.png)

명령 패턴의 컴포넌트들

- 명령(Command) : 함수 또는 함수를 호출하는데 필요한 정보를 캡슐화하는 객체
- 클라이언트(Client) : 명령을 생성하고 호출자(Invoker)에게 제공하는 컴포넌트
- 호출자(Invoker) : 대상(target)에서 명령의 실행을 담당하는 컴포넌트
- 대상(Target) : 호출의 주제이다. 단일한 함수거나 객체의 멤버 함수일 수 있다.

이 네 가지 컴포넌트는 패턴을 구현하려는 방식에 따라 크게 달라질 수 있다.  
작업을 직접 실행하는 대신 명령 패턴을 사용하는 여러 애플리케이션들이 있다.

- 명령은 나중에 실행하도록 예약할 수 있다.
- 명령은 쉽게 직렬화하여 네트워크를 통해 전송할 수 있다.  
  이 간단한 속성을 통해 원격 시스템에 작업을 배포하고, 브라우저에서 서버로 명령을 전송하고, **RPC(Remote Procedure Call, 원격 프로시저 호출)** 시스템을 만드는 등의 작업을 수행할 수 있다.
- 명령을 사용하면 시스템에서 실행된 모든 작업의 기록을 쉽게 유지할 수 있다.
- 명령은 데이터를 동기화하고 충돌을 해결하기 위한 몇몇 알고리즘에서 중요한 부분이다.
- 실행 예약된 명령은 아직 실행되지 않은 경우 취소시킬 수 있다.  
  명령이 실행되기 전의 시점으로 애플리케이션의 상태를 가져와서 되돌릴 수도 있다.(취소)
- 여러 명령을 함께 그룹화할 수 있다.  
  이는 원자적 트랜잭션을 생성하거나, 그룹의 모든 작업을 한번에 실행하는 메커니즘을 구현하는데 사용할 수 있다.
- 중복제거, 결합 및 분할 같은 일련의 명령에 대해 다양한 종류의 변환을 수행하거나, 텍스트 편집 협업과 같이 오늘날 대부분의 실시간 협업 소프트웨어 기반인 OP(Operational transformation)와 같은 더 복잡한 알고리즘을 적용할 수 있다.

네트워킹 및 비동기 실행이 핵심적인 동작인 Node.js와 같은 플랫폼에서 이 패턴이 얼마나 중요한지 명확하게 보여준다.

## 9-6-1 작업(Task) 패턴

명령 패턴읜 가장 기본적이고 사소한 구현인 **작업 패턴**부터 시작할 수 있다.  
JavaScript에서 호출을 나타내는 객체를 만드는 가장 쉬운 방법은 함수 주위에 클로저를 만들거나 **함수를 바인드**하는 것이다.

```tsx
function createTask(target, ...args) {
  return () => {
    target(...args);
  };
}

function run(name, age) {
  console.log(`My name is ${name} and ${age} years old.`);
}
const 클로저 = createTask(run, 'minwoo', '32');
클로저();

console.log('---------');

const 바인드 = run.bind(null, 'minwoo', '32');
바인드();
```

이 기술을 사용하면 별도의 컴포넌트를 통해 작업 실행을 제어하고 예약할 수 있다.  
이는 본질적으로 명령 패턴의 호출자(Invoker)와 동일하다.

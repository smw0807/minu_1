# 9-5 미들웨어

Node.js에서 가장 독특판 패턴 중 하나는 **미들웨어** 패턴이다.  
경험이 없는 사람들, 엔터프라이즈 프로그래밍 세계에서 온 개발자들에게 있어서는 혼란스러운 용어 중 하나이다.  
엔터프라이즈 아키텍처에서 이 전문 용어는 OS API, 네트워크 통신, 메모리 관리 등과 같은 하위 수준 메커니즘을 추상화하는데 도움이 되는 다양한 소프트웨어 제품군을 나타낸다.  
미들웨어라는 용어는 CORBA, 엔터프라이즈 서비스 버스, Spring, JBoss, WebSphere 와 같은 용어들을 떠오리게 하지만, 하위 계층의 서비스들과 응용프로그램 사이에서 접착제 역할을 하는 소프트웨어 계층(말 그대로 중간에 있는 소프트웨어)이라고 일반화 할 수 있을 것이다.

## 9-5-1 Express에서 미들웨어

Express는 미들웨어라는 용어를 대중화하여 매우 구체적으로 디자인 패턴을 구현했다.  
실제로 Express의 미들웨어는 파이프라인으로 구성되어 들어오는 HTTP 요청과 해당 요청에 대한 응답을 처리하는 서비스 집합(일반적으로 함수)을 나타낸다.

Express는 매우 자유롭고 작은 웹 프레임워크로 유명하며, 미들웨어 패턴이 그 주요한 원인이다.  
Express 미들웨어는 다음과 같은 특징이 있다.

```tsx
function (req, res, next) { ... }
```

req는 수신된 HTTP 요청, res는 응답, next는 현재 미들웨어가 작업을 완료하고 파이프라인의 다음 미들웨어로 트리거할 때 호출되는 콜백이다.  
Express 미들웨어가 수행하는 작업의 예는 다음과 같다.

- 요청의 본문 분석
- 요청과 응답의 압축/압축해제
- 접근 로그 생성
- 세션 관리
- 암호화된 쿠키 관리
- CSRF(Cross-Site Request Forgery) 보호 제공

이러한 작업들은 애플리케이션의 주요 비즈니스 로직과 엄격하게 관련되지 않으며 웹 서버의 필수적인 핵심 기능도 아니다.  
나머지 애플리케이션에 대한 지원을 제공하고 실제 요청을 처리하는 핸들러가 주요 비즈니스 로직에만 집중할 수 있도록 하는 액세서리들이다.

## 9-5-2 패턴으로서의 미들웨어

Express에서 미들웨어를 구현하는데 사용되는 기술은 새로운 것이 아니며, 실제로 Node.js의 **인터셉터 필터(Intercepting FIlter)** 패턴 및 **책임 사슬(Chain of Responsibility)** 패턴으로 여겨질 수 있다.  
보다 일반적인 용어로 스트림을 연상하게 하는 **파이프라인** 처리로 보인다.  
오늘날 Node.js에서 미들웨어라는 단어는 Express 프레임워크의 경계를 훨씬 넘어서 사용되며, 함수 형태의 처리 장치, 필터 및 핸들러들의 집합이 모든 종류의 데이터 전처리 및 후처리를 수행하기 위해 비동기적으로 연결되어 형성된 특정 패턴을 말한다.  
이 패턴의 주요 장점은 유연성이다.  
미들웨어 패턴을 사용하면 매주 적은 노력으로 플러그인 인프라를 얻을 수 있으며, 새로운 필터와 핸들러로 시스템을 확장하는 간결한 방법을 제공한다.

미들웨어 패턴의 필수적인 컴포넌트는 미들웨어 함수들을 조직하고 실행하는 **미들웨어 관리자(Middleware Manager)**이다.  
패턴의 가장 중요한 구현 세부 사항은 다음과 같다.

- 새로운 미들웨어는 use() 함수를 호출하여 등록할 수 있다.
- 처리를 위해 새 데이터가 수신되면 등록된 미들웨어들이 비동기 순차 실행 흐름으로 호출된다.  
  파이프라인의 각 유닛은 이전 유닛의 실행 결과를 입력으로 받는다.
- 각 미들웨어는 데이터의 추가적인 처리를 중단시킬 수 있다.  
  이는 특수한 함수를 호출하거나, 콜백을 호출하지 않거나(미들웨어가 콜백을 사용할 경우), 오류를 전파하여 동작한다.  
  오류 상황은 일반적으로 오류 처리 전용의 다른 미들웨어 시퀀스를 시작시킨다.

파이프라인에서 데이터가 처리되고 전파되는 방식에 대한 엄격한 규칙은 없다.  
파이프라인에서 데이터 수정 사항을 전파하기 위한 전략은 다음과 같다.

- 추가 속성 또는 함수를 사용하여 입력된 데이터를 증강한다.
- 데이터의 불변성을 지키면서 처리하고 항상 새로운 복사본으로 처리결과를 반환한다.

https://www.notion.so/smw0807/31864a09af1d4b24965199792d53b27a?pvs=4#87d5722a56204d1ea4e12d56b81eb759

# 12-3 복잡한 애플리케이션 분해

이번 섹션에서는 애플리케이션을 기능 및 서비스별로 **분해**하여 크기를 조정하는 스케일 큐브의 Y축에 중점을 둘 것이다.  
여기서 배우게 될 이 기술을 사용하면 애플리케이션의 용량 뿐만 아니라 가장 중요한 복잡성도 확장할 수 있다.

## 12-3-1 모놀로식 아키텍처

모놀로식이라는 용어는 애플리케이션의 모든 서비스가 상호 연결되어 거의 구분할 수 없는 모듈성이 없는 시스템을 떠올리게 만든다.

항상 그렇지많은 않은데, 종종 모놀리식 시스템은 고도로 모듈화된 아키텍처와 내부 컴포넌트 간에 좋은 수준의 디커플링을 가지고 있다.

완벽한 예로는 **모놀리식 커널**이라는 범주의 일부인 LinuxOS 커널이다. (생태계 및 Unix 철학과 완벽하게 반대됨)
Linux에는 시스템이 실행되는 동안에도 동적으로 로드 및 언로드할 수 있는 수천 개의 서비스와 모듈이 존재한다.  
그러나 이들은 모두 커널 모드에서 실행된다.  
즉, 이들 중 하나에서 오류가 발생하면 전체 OS가 다운될 수 있다.  
이 접근 방식은 운영체제의 핵심 서비스만 커널모드에서 실행되고, 나머지는 일반적으로 각각의 고유한 프로세스가 있는 사용자 모드에서 실행되는 마이크로 커널 아키텍처와 반대이다.  
마이크로 커널 접근 방식의 가장 큰 장점은 구성 서비스 중 하나의 문제로 인해 전체 시스템의 안정성에 영향을 주지 않고 격리된 상태에서 충돌이 발생할 가능성이 높다는 것이다.

현대의 모놀리식 애플리케이션은 모놀리식 커널과 비슷하다.  
컴포넌트 중 하나라도 실패하면 전체 시스템이 영향을 받는다.  
즉, Node.js 용어로 번역하면 모든 서비스가 동일한 코드 베이스의 일부이며(복제되지 않은 경우) 단일 프로세스에서 실행된다.

일반적인 전자상거래 애플리케이션의 아키텍처로 모듈식 구조이다.  
모든 모듈이 동일한 코드 베이스의 일부이며 단일 애플리케이션의 일부로 실행된다.  
이 모놀리식 아키텍처는 컴포넌트 중 하나에 오류가 발생하면 전체 온라인 상점이 다운될 수 있다.

이러한 유형의 아키텍처의 또 다른 문제는 모듈 간의 상호 연결성이다.  
모듈들이 모두 동일한 애플리케이션 내에 존재한다는 사실을 개발자가 모듈 간의 상호 작용과 연결을 구축하는 것은 매우 간단하게 만든다.  
내부 모듈 간의 낮은 결합을 유지하는 것은 모놀리식 애플리케이션에서 매우 어렵다.  
부분적으로는 모듈 간의 경계가 항상 명확하거나 적절하게 적용되지 않기 때문이다.

---

<aside>
💡 상호 연결성이 좋다?   
→ 모듈 간의 상호 연결성이 좋다는 것은, 모듈들이 서로 통신하고 데이터를 공유하는 데 있어서 효율적이라는 의미입니다. 모놀리식 아키텍처에서는 모든 모듈이 같은 애플리케이션 내에 있기 때문에 서로 통신하기가 더 간편합니다. 그러나 이것이 항상 좋은 것만은 아닙니다. 이로 인해 모듈이 서로에게 너무 의존적이 되어 하나의 모듈에 문제가 생기면 다른 모듈에도 영향을 미칠 수 있습니다.
   
낮은 결합?   
→ 각 모듈이 독립적으로 기능할 수 있도록, 즉 다른 모듈에 대한 의존성을 최소화하도록 설계하는 것을 말합니다. 낮은 결합을 유지하는 것은 시스템의 유연성과 유지보수성을 향상시킵니다.   
모듈들이 같은 코드 베이스와 개발 환경을 공유하기 때문에, 개발자들이 의도치 않게 모듈 간의 강한 의존성을 만들어 낼 수 있습니다. 이는 각 모듈을 개별적으로 수정하거나 업데이트할 때 다른 모듈에 영향을 줄 수 있어 문제가 됩니다.
   
모듈 간의 경계가 항상 명확하지 않거나 적절하게 적용되지 않는다?   
→ 모놀리식 아키텍처에서 모듈들이 코드상에서 분리되어 있어야 하지만, 실제로는 그렇지 않은 경우를 말합니다. 즉, 한 모듈의 코드가 다른 모듈의 기능과 혼합되거나 서로 겹치는 경우가 발생할 수 있습니다. 이는 코드의 모듈화가 제대로 이루어지지 않음을 의미하며, 이로 인해 한 부분을 변경할 때 예상치 못한 부작용이 다른 부분에 나타날 수 있습니다.

</aside>

- **낮은 결합(Low Coupling)**: 이는 함수가 다른 함수나 모듈과 느슨하게 연결되어 있다는 것을 의미합니다. 즉, 한 함수가 변경되더라도 다른 함수에 큰 영향을 주지 않습니다. 낮은 결합도를 가진 함수는 일반적으로 재사용이 가능하고, 다른 부분의 코드 변경으로부터 비교적 안전하며, 시스템의 다른 부분과 독립적으로 유지보수가 가능합니다.
- **높은 의존성(High Dependency)**: 이는 어떤 함수가 다른 특정 함수나 모듈에 크게 의존하고 있다는 것을 의미합니다. 이 경우, 의존하는 함수나 모듈에 변경이 생기면, 해당 함수도 영향을 받게 됩니다. 높은 의존성을 가진 함수는 변경 사항에 민감하고, 잠재적으로 유지보수가 어려워질 수 있습니다.

---

**높은 결합**은 종종 애플리케이션의 성장에 주요 장애물 중의 하나이며, 복잡성 측면에서 확장성을 방해한다.  
복잡한 종속성 그래프는 시스템의 모든 부분이 책임이 되고 제품의 전체 수명 동안 유지되어야 하며 모든 컴포넌트가 젠가 나무 블록과 같으므로, 모든 변경 사항을 신중하게 평가해야 함을 의미한다.  
그들 중 하나를 이동하거나 제거하면 전체 타워가 무너질 수 있다.  
이로 인해 프로젝트의 복잡성 증가에 대처하기 위한 빌드 규칙 및 개발 프로세스가 수립되는 경우가 많다.

## 12-3-2 마이크로서비스 아키텍처

스케일 큐브의 Y축, 서비스 및 기능에 따른 분배 및 분할  
애플리케이션을 필수 컴포넌트로 분해하여 별도의 독립적인 애플리케이션을 만드는 것  
이는 사실상 모놀로식 아키텍처와 반대되는 말이다.  
이것은 유닉스의 척학과 Node.js의 원칙과 완벽하게 일치한다..  
”각 프로그램은 한 가지 역할만 잘 하도록 만들어라.”라는 모토에도 부합하다.

오늘날 **마이크로서비스 아키텍처**는 이러한 유형의 접근 방식에 대한 주요 참조 패턴으로, 일련의 자체적인 서비스가 대규모 단일 애플리케이션을 대체한다.  
접두사 “마이크로(micro)”는 서비스가 가능한 한 작아야 하지만 항상 합리적인 한도 내에 있어야 함을 의미한다.  
단 하나의 웹 서비스만 노출하는 수백 개의 서로 다른 애플리케이션으로 아키텍처를 만드는 것이 반드시 좋은 선택이라고 오해하지는 않아야 한다.  
실제로 서비스가 얼마나 작거나 커야 하는지에 대한 엄격한 규칙은 없다.  
마이크로서비스 아키텍처 설계에서 중요한 것은 크기가 아니다.  
대신 주로 느슨한 결합, 높은 응집력 및 통합 복잡성과 같은 다양한 요인의 집합이다.

### 마이크로서비스 아키텍처의 예

![마이크로서비스 패턴을 사용한 전자상거래 시스템 구현의 예](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc261f43-de91-483d-8946-ac5a65106576/7903e457-35bf-4e51-9b1d-ea6c2bd232ad/Untitled.png)

마이크로서비스 패턴을 사용한 전자상거래 시스템 구현의 예

각 기본 컴포넌트는 자체 데이터베이스와 함께 자체 컨텍스트가 존재하는 자립적이고 독립적인 엔티티이다.  
모두 관련된 일련의 서비스들을 노출하고 있는 독립적인 애플리케이션이다.

서비스의 **데이터 소유권**은 마이크로서비스 아키텍처의 중요한 특성이다.  
이것이 적절한 격리 및 독립 수준을 유지하기 위해 데이터베이스도 분할해야 하는 이유이다.  
고유한 공유 데이터베이스를 사용하면 서비스가 함꼐 작동하는 것이 훨씬 쉬워진다.  
그러나 이것은 또한 서비스(데이터 기반) 간의 결합을 유도하여 서로 다른 애플리케이션을 갖는 몇몇 장점들을 무효화 한다.

위 그림에서 모든 노드를 연결하는 점선은 전체 시스템이 완전히 동작하려면 어떤 식으로든 정보를 교환하고 통신해야 함을 알려준다.  
서비스가 동일한 데이터베이스를 공유하지 않기 때문에 전체 시스템의 일관성을 유지하기 위해 더 많은 통신이 필요하다.  
예를 들어 Checkout 서비스는 가격 및 배송 제한과 같은 Products에 대한 일부 정보를 알아야 하며, 동시에 결제 완료 시 제품의 가용성과 같은 Products 서비스에 저장된 데이터를 업데이트해야 한다.

### 마이크로서비스의 장단점

이 접근 방식은 애플리케이션 개발 방식에 급진적인 변화를 가져와 확장성과 복잡성에 대한 인식을 혁신할 수 있을 것으로 기대되지만, 다른 한편으로는 사소하지 않은 과제를 야기한다.

### 모든 서비스는 소모품이다

각 서비스가 고유한 애플리케이션 컨텍스트에 존재하는 주요 기술적 이점은 충돌이 전체 시스템에 전파되지 않는 다는 것이다.  
목표는 더 작고 변경하기 쉬우며 처음부터 다시 빌드할 수도 있는 진정한 독립적인 서비스들을 만드는 것이다.

모놀로식 애플리케이션에서는 전체 시스템에 영향을 주지 않고 변경하기 위해 할 수 있는 작업이 거의 없다.  
대신 마이크로서비스 아키텍처에서는 다른 데이터베이스 또는 플랫폼을 사용하여 전체 서비스를 처음부터 더 쉽게 다시 구현할 수 있으며, 새로운 구현이 나머지와 동일한 인터페이스를 유지하는 한 나머지 시스템은 이를 인식하지 못할 것이다.

### 플랫폼 및 언어 간의 재사용성

커다란 모놀로식 애플리케이션을 여러 개의 작은 서비스로 분할하면 훨씬 쉽게 재사용할 수 있는 독립적인 단위를 만들 수 있다.  
ElasticSearch는 재사용 가능한 검색 서비스의 좋은 예이다.  
ORY는 마이크로서비스 아키텍처에 쉽게 통합할 수 있는 완전한 인증 및 권한 부여 서비스를 제공하는 재사용 가능한 오픈소스 기술의 또 다른 예이다.

마이크포서비스 접근 방식의 주요 장점은 정보 숨김 수준이 일반적인 모놀리식 애플리케이션에 비해 훨씬 높다.  
이는 상호작용이 일반적인 웹 API 또는 메시지 브로커와 같은 원격 인터페이스를 통해 발생하기 때문에 가능하다.  
때문에 구현의 세부 정보를 훨씬 쉽게 숨기고 서비스 구현 또는 배포 방식의 변경으로부터 클라이언트를 보호할 수 있다.  
예를 들어 웹 서비스를 호출만 하는 클라이언트는 인프라가 확장되는 방식, 사용하는 프로그래밍 언어, 데이터 저장에 사용하는 데이터베이스 등으로부터 보호된다.  
모든 결정은 시스템의 나머지 부분에 잠재적인 영향없이 필요에 따라 재검토 및 조정할 수 있다.

### 애플리케이션을 확장하는 방법

스케일 큐브로 돌아가보면 마이크로서비스는 Y축을 따라 애플리케이션을 확장하는 것과 동일하므로 이미 여러 머신에 부하를 분산하기 위한 솔루션이다.  
또한 마이크로서비스를 큐브의 다른 2차원과 결합하여 애플리케이션을 더욱 확장할 수 있다는 사실을 잊지 말아야 한다.  
예를 들어, 각 서비스를 복제하여 더 많은 트래픽을 처리할 수 있으며 독립적으로 확장할 수 있어 더 나은 리소스 관리가 가능하다는 것이다. (결재는 2개 상품은 1개로 서비스를 한다 뭐 이런 느낌인가?)

### 마이크로서비스의 과제

관리할 노드가 많을수록 통합, 배포 및 코드 공유 측면에서 복잡성이 증가한다.  
기존 아키텍처의 일부 문제들을 해결하지만 많은 새로운 문제들을 불러일으킨다.  
서비스가 상호작용하게 하기 위해서 어떻게 해야할지,  
많은 수의 애플리케이션의 배포, 확장 및 모니터링해야 할 때 온전성을 유지하기 위해선 어떻게 해야할지,  
서비스간에 코드를 공유하고 재사용하려면 어떻게 해야할지.

클라우드 서비스와 최신 DevOps 방법론은 이러한 질문에 대한 해답을 제공할 수 있으며 Node.js를 사용하면 많은 도움이 될 수 있다.  
모듈 시스템은 서로 다른 프로젝트 간에 코드를 공유할 수 있는 완벽한 동반자이다.  
Node.js는 마이크로서비스 아키텍처와 같은 분산 시스템의 노드가 될 수 있도록 만들어져 있다.

## 12-3-3 마이크로서비스 아키텍처의 통합 패턴

마이크로서비스의 가장 어려운 문제 중 하나는 모든 노드를 연결하여 공동작업을 수행하는 것이다.  
예를 들어, 전자상거래 애플리케이션의 Cart 서비스는 추가할 Products가 없으면 거의 의미가 없다.

다양한 서비스 간의 상호 작용을 필요로 하는 다른 요소도 있다.  
예를 들면, Search 서비스는 사용 가능한 Products를 알아야 하며 정보를 최신의 상태로 유지해야 한다.

통합 전략을 설계할 때, 시스템의 서비스 간에 어떤 결합을 도입할지를 고려하는 것도 중요하다.  
분산 아키텍처를 설계할 때는 로컬에서 모듈이나 하위 시스템을 설계할 때 사용하는 관행과 원칙이 포함된다는 사실을 잊어선 안된다.  
따라서 서비스의 재사용 및 확장성과 같은 속성도 고려해야 한다.

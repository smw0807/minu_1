https://www.notion.so/smw0807/31864a09af1d4b24965199792d53b27a?pvs=4#87d5722a56204d1ea4e12d56b81eb759

# 12-3 복잡한 애플리케이션 분해

이번 섹션에서는 애플리케이션을 기능 및 서비스별로 **분해**하여 크기를 조정하는 스케일 큐브의 Y축에 중점을 둘 것이다.  
여기서 배우게 될 이 기술을 사용하면 애플리케이션의 용량 뿐만 아니라 가장 중요한 복잡성도 확장할 수 있다.

## 12-3-1 모놀로식 아키텍처

모놀로식이라는 용어는 애플리케이션의 모든 서비스가 상호 연결되어 거의 구분할 수 없는 모듈성이 없는 시스템을 떠올리게 만든다.

항상 그렇지많은 않은데, 종종 모놀리식 시스템은 고도로 모듈화된 아키텍처와 내부 컴포넌트 간에 좋은 수준의 디커플링을 가지고 있다.

완벽한 예로는 **모놀리식 커널**이라는 범주의 일부인 LinuxOS 커널이다. (생태계 및 Unix 철학과 완벽하게 반대됨)
Linux에는 시스템이 실행되는 동안에도 동적으로 로드 및 언로드할 수 있는 수천 개의 서비스와 모듈이 존재한다.  
그러나 이들은 모두 커널 모드에서 실행된다.  
즉, 이들 중 하나에서 오류가 발생하면 전체 OS가 다운될 수 있다.  
이 접근 방식은 운영체제의 핵심 서비스만 커널모드에서 실행되고, 나머지는 일반적으로 각각의 고유한 프로세스가 있는 사용자 모드에서 실행되는 마이크로 커널 아키텍처와 반대이다.  
마이크로 커널 접근 방식의 가장 큰 장점은 구성 서비스 중 하나의 문제로 인해 전체 시스템의 안정성에 영향을 주지 않고 격리된 상태에서 충돌이 발생할 가능성이 높다는 것이다.

현대의 모놀리식 애플리케이션은 모놀리식 커널과 비슷하다.  
컴포넌트 중 하나라도 실패하면 전체 시스템이 영향을 받는다.  
즉, Node.js 용어로 번역하면 모든 서비스가 동일한 코드 베이스의 일부이며(복제되지 않은 경우) 단일 프로세스에서 실행된다.

일반적인 전자상거래 애플리케이션의 아키텍처로 모듈식 구조이다.  
모든 모듈이 동일한 코드 베이스의 일부이며 단일 애플리케이션의 일부로 실행된다.  
이 모놀리식 아키텍처는 컴포넌트 중 하나에 오류가 발생하면 전체 온라인 상점이 다운될 수 있다.

이러한 유형의 아키텍처의 또 다른 문제는 모듈 간의 상호 연결성이다.  
모듈들이 모두 동일한 애플리케이션 내에 존재한다는 사실을 개발자가 모듈 간의 상호 작용과 연결을 구축하는 것은 매우 간단하게 만든다.  
내부 모듈 간의 낮은 결합을 유지하는 것은 모놀리식 애플리케이션에서 매우 어렵다.  
부분적으로는 모듈 간의 경계가 항상 명확하거나 적절하게 적용되지 않기 때문이다.

---

<aside>
💡 상호 연결성이 좋다?   
→ 모듈 간의 상호 연결성이 좋다는 것은, 모듈들이 서로 통신하고 데이터를 공유하는 데 있어서 효율적이라는 의미입니다. 모놀리식 아키텍처에서는 모든 모듈이 같은 애플리케이션 내에 있기 때문에 서로 통신하기가 더 간편합니다. 그러나 이것이 항상 좋은 것만은 아닙니다. 이로 인해 모듈이 서로에게 너무 의존적이 되어 하나의 모듈에 문제가 생기면 다른 모듈에도 영향을 미칠 수 있습니다.
   
낮은 결합?   
→ 각 모듈이 독립적으로 기능할 수 있도록, 즉 다른 모듈에 대한 의존성을 최소화하도록 설계하는 것을 말합니다. 낮은 결합을 유지하는 것은 시스템의 유연성과 유지보수성을 향상시킵니다.   
모듈들이 같은 코드 베이스와 개발 환경을 공유하기 때문에, 개발자들이 의도치 않게 모듈 간의 강한 의존성을 만들어 낼 수 있습니다. 이는 각 모듈을 개별적으로 수정하거나 업데이트할 때 다른 모듈에 영향을 줄 수 있어 문제가 됩니다.
   
모듈 간의 경계가 항상 명확하지 않거나 적절하게 적용되지 않는다?   
→ 모놀리식 아키텍처에서 모듈들이 코드상에서 분리되어 있어야 하지만, 실제로는 그렇지 않은 경우를 말합니다. 즉, 한 모듈의 코드가 다른 모듈의 기능과 혼합되거나 서로 겹치는 경우가 발생할 수 있습니다. 이는 코드의 모듈화가 제대로 이루어지지 않음을 의미하며, 이로 인해 한 부분을 변경할 때 예상치 못한 부작용이 다른 부분에 나타날 수 있습니다.

</aside>

- **낮은 결합(Low Coupling)**: 이는 함수가 다른 함수나 모듈과 느슨하게 연결되어 있다는 것을 의미합니다. 즉, 한 함수가 변경되더라도 다른 함수에 큰 영향을 주지 않습니다. 낮은 결합도를 가진 함수는 일반적으로 재사용이 가능하고, 다른 부분의 코드 변경으로부터 비교적 안전하며, 시스템의 다른 부분과 독립적으로 유지보수가 가능합니다.
- **높은 의존성(High Dependency)**: 이는 어떤 함수가 다른 특정 함수나 모듈에 크게 의존하고 있다는 것을 의미합니다. 이 경우, 의존하는 함수나 모듈에 변경이 생기면, 해당 함수도 영향을 받게 됩니다. 높은 의존성을 가진 함수는 변경 사항에 민감하고, 잠재적으로 유지보수가 어려워질 수 있습니다.

---

**높은 결합**은 종종 애플리케이션의 성장에 주요 장애물 중의 하나이며, 복잡성 측면에서 확장성을 방해한다.  
복잡한 종속성 그래프는 시스템의 모든 부분이 책임이 되고 제품의 전체 수명 동안 유지되어야 하며 모든 컴포넌트가 젠가 나무 블록과 같으므로, 모든 변경 사항을 신중하게 평가해야 함을 의미한다.  
그들 중 하나를 이동하거나 제거하면 전체 타워가 무너질 수 있다.  
이로 인해 프로젝트의 복잡성 증가에 대처하기 위한 빌드 규칙 및 개발 프로세스가 수립되는 경우가 많다.

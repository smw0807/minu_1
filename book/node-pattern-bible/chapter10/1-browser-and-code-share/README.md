# 10-1 브라우저와 코드 공유

Node.js의 주요 관심 포인트 중 하나는 실제로 일부 브라우저(Google Chrome, Microsoft Edge)에서 구동하는 JavaScript 엔진인 V8이다.  
동일한 JavaScript 엔진을 공유하는 것만으로도 Node.js와 브라우저 간에 코드를 쉽게 공유할 수 있다고 생각할 수 있다.  
그러나 이 단순하고 독립적이면서 일반적인 일부의 코드만을 공유하려는 경우가 아닌 한, 항상 가능한 일은 아니다.

클라이언트와 서버 모두에 대한 코드를 개발하려면 동일한 코드가 본질적으로 다른 두 환경에서 제대로 실행될 수 있도록 하는데 무시할 수 없는 수준의 노력이 필요하다.  
Node.js에서는 DOM이나 수명이 긴 뷰(View)가 없지만, 브라우저에서는 기본적으로 운영체제와 상호작용할 파일 시스템 및 기타 인터페이스가 존재하지 않는다.

최신 JavaScript 기능에 대한 지원 수준에도 서로 다른 점이 있다.  
Node.js를 대상으로 한다면 서버에서 실행되는 Node.js의 버전을 알고있기 때문에 최신 언어 기능을 안전하게 채택할 수 있다.  
하지만 브라우저용 JavaScript 코드를 작성할 때는 동일한 확신을 가질 수 없다.  
이는 사용자마다 브라우저가 달라 최신 언어 기능과의 호환성 수준이 다르기 때문이다.  
일부 사용자는 async/await을 지원하는 최신 브라우저를 사용할 수도 있고, 지원하지 않는 구 버전의 브라우저를 사용할 수 도 있기 때문이다.

애플리케이션이 브라우저 호환 코드와 Node.js 코드간에 전환을 동적으로 또는 빌드 시에 할 수 있도록 하는 추상화, 패턴 및 도구들의 도움을 받아 수행할 수 있다.  
이 새로운 가능성에 대한 관심이 높아지면서 생태계의 많은 라이브러리와 프레임워크가 두 환경을 모두 지원하기 시작했다.  
Node.js에서 npm 패키지를 사용하는 경우 브라우저에서도 원활하게 작동할 가능성이 높다.  
그러나 이것이 브라우저와 Node.js 모두에서 문제없이 애플리케이션을 실행할 수 있다는 것을 보장하기에는 충분하지 않은 경우가 많다.  
그래서 크로스 플랫폼 코드를 개발할 때는 항상 신중한 디자인이 필요하다.

## 10-1-1 크로스 플랫폼 컨텍스트의 JavaScript 모듈

브라우저와 서버 간에 일부 코드를 공유하고 싶을 때 가장 먼저 부딪히는 장벽이 Node.js에서 사용하는 모듈 시스템과 브라우저에서 사용되는 모듈 시스템의 이기종 환경 간의 불일치이다.  
또 다른 문제는 브라우저에는 require() 함수나 모듈을 해결할 수 있는 파일 시스템이 없다는 것이다.  
대부분 최신 브라우저는 import 및 ES 모듈을 지원하지만 웹 사이트를 방문하는 일부 사용자는 이러한 최신 브라우저를 사용하지 않을 수도 있다.

이러한 문제 외에도 서버와 브라우저에 대한 코드 배포의 차이점도 고려해야 한다.  
서버에서 모듈은 파일 시스템에서 직접로드되는 데, 이것은 일반적으로 성능이 요구되는 작업이므로 개발자는 코드를 작은 모듈로 분할하여 서로 다른 로직 단위를 작고 체계적으로 유지하는 것이 좋다.

브라우저에서 스크립트를 적재하는 모델은 완전히 다르다.  
이 프로세스는 브라우저가 원격 엔드포인트에서 HTML 페이지를 다운로드하는 것으로 시작된다.  
HTML 코드는 브라우저에 의해 구문이 분석되어 다운로드 및 실행해야 하는 스크립트 파일에 대한 참조를 알아낸다.  
다운로드할 스크립트가 많을 수록 브라우저는 애플리케이션을 완전히 초기화하기 전에 상당수의 HTTP 요청을 발생시키고 여러 스크립트 파일을 다운로드하고 구문을 분석해야 한다.  
이는 스크립트 파일이 많을 수록 브라우저에서 애플리케이션을 실행하기 위해 지불해야 하는 성능 저하가 매우 클 수 있다.  
이러한 성능 저하의 일부는 **HTTP/2 Server Push**, 클라이언트 측의 캐싱, 사전로드 또는 유사한 기술을 채택하여 완하할 수 있지만 근본적인 문제는 여전히 존재한다.

이 문제를 해결하는 일반적인 방법은 브라우저용 패키지(또는 **번들**)를 “빌드”하는 것이다.  
일반적으로 빌드 프로세스는 모든 소스 파일을 매우 적은 수의 번들로 조합하여 브라우저가 각 페이지 방문에 대해 많은 수의 스크립트를 다운로드할 필요가 없도록 한다.  
빌드 프로세스는 파일 수를 줄이는 것 뿐만 아니라 최적화들을 수행할 수 있다.  
또 다른 일반적인 최적화는 코드 축소로, 기능을 변경하지 않고도 문자 수를 최소화할 수 있다.  
이것은 일반적으로 주석을 제거하고, 사용하지 않는 코드를 제거하고, 함수 및 변수 이름을 변경함으로써 수행된다.

### 모듈 번들러

서버와 브라우저 모두에서 최대한 원활하게 작동할 수 있는 코드를 작성하려면 빌드 시 모든 종속성을 함께 “번들”하는데 도움을 주는 도구가 필요하다. 이러한 도구를 일반적으로 **모듈 번들러**라고 한다.  
아래는 모듈 번들러를 사용해 공유 코드를 서버와 클라이언트에 적재할 수 있는 방법의 예시이다.

![서버와 브라우저에서 공유 모듈 로드(모듈 번들러 사용)](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc261f43-de91-483d-8946-ac5a65106576/9d434a2f-441f-4240-b89a-9b3b161e39f7/Untitled.png)

서버와 브라우저에서 공유 모듈 로드(모듈 번들러 사용)

위 그림을 보면 코드가 서버 측과 브라우저에서 다르게 적재되고 처리되는 것을 볼 수 있다.

- 서버 측: Node.js는 serverApp.js를 직접 실행하고, serverApp.js 파일은 moduleA, B, C 모듈을 가져온다.
- 브라우저: moduleA, B, C를 임포트하는 browserApp.js가 있다.  
  인덱스 파일에 browserApp.js가 포함되어 있다면 앱이 완전히 초기화되기 전에 총 5개의 파일(index.html, browserApp.js 및 3개의 종속 모듈)을 다운로드해야 한다.  
  모듈 번들러를 사용하면 browserApp.js 및 모든 종속성을 사전에 처리하고 main.js라는 하나의 번들을 생성하여 총 파일 수를 2개로 줄일 수 있다. 그런 다음 index.html에서 참조하여 브라우저에서 로드한다.

브라우저에서는 일반적으로 **빌드**와 **런타임**이라는 두 가지 논리적인 단계를 처리해야 하는 반면,
서버에서는 일반적으로 빌드 단계가 필요하지 않으며 소스 코드를 직접 실행할 수 있다.

모듈 번들러 중 인기있는 것들로는 아래와 같다.

- 웹팩 : 가장 인기 있고, 현재 사용 가능한 가장 안전하고 성숙한 모듈 번들러 중 하나
- Parcel : 빠른 환경설정 없이 “자동 마법사처럼” 작동하는 것을 목표로 한다.
- Rollup : ESM을 완전히 지원하고, 트리 쉐이킹 및 불필요한 코드 제거와 같은 다양한 최적화를 제공하는 최초의 모듈 번들러 중 하나
- Browserify : CommonJS를 지원하는 첫 번째 모듈 번들러이며 여전히 널리 채택되고 있다.

이 외에도 FuseBox, Brunch, Microbundle 등이 있다.

### 모듈 번들러의 작동 원리

모듈 번들러는 애플리케이션의 소스 코드(입력 모듈 및 해당 종속성의 형식)를 가져와 하나 이상의 번들 파일을 생성하는 도구로 정의할 수 있다.  
번들을 만드는 프로세스는 앱의 비즈니스 로직을 변경하지 않는다.  
브라우저에서 실행되도록 최적화된 파일만 생성한다.

**Babe**l과 같은 **트랜스파일러(transpiler)**를 사용하여 번들러가 브라우저가 로드해야 할 총 파일 수를 줄이는데 도움을 주는 것 뿐만 아니라 번들러는 그 이상을 수행할 수 있다.  
’트랜스파일러’는 소스 코드를 처리해서 최신 JavaScrip 구문을 동등한 ECMAScript5 구문으로 변환하여 다양한 브라우저에서 애플리케이션을 올바르게 실행할 수 있도록 하는 도구이다.  
일부 ‘모듈 번들러’를 사용하면 JavaScript 코드뿐만 아니라 이미지 및 스타일 시트와 같은 다른 리소스들도 전처리하고 최적화할 수 있다.  
모듈 번들러 작업은 **종속성 해결** 및 **패킹**이라는 두 단계로 나눌 수 있다.

### 종속성 해결

종속성 해결 단계는 기본 모듈(**진입점**이라고도 함)에서 시작하여 코드를 탐색하고 모든 종속성을 발견하는 것을 목표로 한다.  
번들러가 이를 수행할 수 있는 방법은 종속성을 **종속성 그래프**라고 하는 비순환 직접 그래프로 나타내는 것이다.

### 패킹(Packing)

모듈맵은 종속성 해결 단계의 최종 출력이다.
’패킹’ 단계에서 모듈 번들러는 모듈맵을 가져와서 원래 애플리케이션의 모든 비즈니스 로직을 포함하는 단일 JavaScript 파일인 실행 가능한 번들로 변환한다.

모듈맵 안에 애플리케이션의 원래 코드베이스를 이미 작성해 놓았다. 브라우저가 올바르게 실행할 수 있는 것으로 변환하고 결과 번들 파일을 저장하는 방법을 찾는 것이다.

모듈맵의 구조를 감안할 때 모듈맵을 감싸는 몇 줄의 코드만으로 실제로 이를 수행할 수 있다.

```jsx
((modulesMap) => { //1
	cosnt require = (name) => { //2
		const module = { exports: {}}; //3
		modulesMap[name](module, require); //4
		return module.exports; //5
	}
	require('app.js'); //6
})(
	{
		'app.js': (module, require) => {/* ... */},
		'calculator.js': (module, require) => {/* ... */},
		'display.js': (module, require) => {/* ... */},
		'parser.js': (module, require) => {/* ... */},
		'resolver.js': (module, require) => {/* ... */}
	}
)
```

1. 전체 모듈맵을 인자로 받는 IIFE(Immediately Invoked Function Expression)이다.
2. 함수가 실행되면사용자 정의 require 함수를 정의한다.  
   이 함수는 모듈 이름을 입력으로 받고 modulesMap에서 해당 모듈을 로드하고 실행한다.
3. module객체가 초기화된다.  
   이 객체는 속성을 가지지 않는 exports라는 속성 하나만 존재한다.
4. 이 시점에서 주어진 모듈의 팩토리함수가 호출된다.  
   modules 객체와 require 함수 자체에 대한 참조를 전달한다.  
   이것은 서비스 로케이터 패턴의 구현이다.  
   팩토리함수가 실행되면 모듈이 익스포트하는 함수들을 추가하여 module 객체를 수정한다.  
   팩토리함수는 인자로 전달된 require 함수를 사용하여 다른 모듈을 재귀적으로 요청할 수 있다.
5. 이전 단계에서 호출된 팩토리함수가 추가한 module.exports 객체를 반환한다.
6. 마지막 단계는 종속성 그래프의 진입점을 require하는 것이다.(app.js)  
   이 마지막 단계가 전체 애플리케이션을 시작시킨다.  
   진입점을 로드하면 모든 종속성을 올바른 순서로 로드하고 실행한 다음 자체 비즈니스 로직을 실행한다.

자급자족 모듈 시스템…  
원래 여러 파일로 구성된 앱을 모든 코드가 단일 파일에 포함된 동등한 앱으로 변환된다. 이 결과가 번들 파일이다.

# 10-2 크로스 플랫폼 개발의 기초

다른 플랫폼 용으로 개발할 때 가장 일반적인 문제는 가능한 한 많은 코드를 재사용하는 동시에 플랫폼 별로 세부 사항에 대한 특수한 구현을 제공하는 방법이다.

## 10-2-1 런타임 코드 분기

호스트 플랫폼을 기반으로 다양한 구현을 제공하는 가장 간단하고 직관적인 기술은 코드를 동기적으로 분기하는 것이다.  
런타임에서 호스트 플랫폼을 인식한 다음 if…else 문으로 구현을 동적으로 전환하는 메커니즘이 있어야 한다.  
일부 일반적인 접근 방식에는 Node.js 또는 브라우저에서만 사용할 수 있는 전역 변수를 확인하는 방식이 포함된다.

예를 들면 전역 변수 window의 존재를 확인하는 것을 들 수 있다.

```js
export function sayHello(name) {
  if (typeof window !== 'undefined' && window.document) {
    // client-side code
    return nunjucks.renderString(template, { name });
  }
  // Node.js code
  return '';
}
```

### 런타임 코드 분기의 문제점

Node.js와 브라우저 사이를 전환하기 위해 런타임 분기 방식을 사용하는 것은 확실히 목적을 위해 사용할 수 있는 가장 직관적이고 간단한 패턴이다. 그러나 몇 가지 불편함이 있다.

- 두 플랫폼의 코드는 동일한 모듈에 포함되어 있으므로 최종 번들에 포함된다.  
  이는 사용되지 않는 불필요한 코드를 추가시켜 번들의 크기를 증가시킨다.  
  사용되지 않는 코드에 암호화 키나 API 키 같이 사용자의 브라우저로 전송하면 안되는 중요한 정보가 포함되어 있을 수도 있다.  
  이 경우 이러한 접근 방식은 심각한 보안 문제를 초래할 수 있다.
- 너무 광범위하게 사용하면 비즈니스 로직이 플랫폼 간 호환성을 추가하기 위한 로직과 섞이기 때문에 코드의 가독성을 상당히 저해할 수 있다.
- 동적 분기를 사용하여 플랫폼에 따라 다른 모듈을 적재하면 대상 플랫폼에 관계없이 모든 모듈이 최종 번들에 추가된다.
- 번들러는 빌드 시 런타임 변수의 값을 알 수 있는 명확한 방법이 없으므로(변수가 상수가 아닌 한) 항상 최종 번들에 포함된다.
- ES 모듈 import는 항상 파일 맨 위에 선언적으로 정의되며 현재 환경을 기반으로 import문을 필터링 할 방법이 없다.  
  번들러는 조건부로 임포트된 기능 중에서 어느 부분을 사용하는지 파악하지 않으며 임포트된 모든 코드를 포함시킨다.

이러한 특성으로 인해, 변수를 사용해서 동적으로 임포트한 모듈들은 번들에 포함되지 않는다.  
하지만, 웹팩이 이러한 제약사항 중 일부를 극복하고 특정 상황에서 동적 요구사항에 대해 가능한 모든 값을 추측할 수 있다는 점은 인상적이긴 하다.

## 10-2-2 빌드시 코드 분기

플러그인을 이용하여...

## 10-2-3 모듈 스와핑

서버용과 브라우저용으로 모듈 파일 분리...

## 10-2-4 크로스 플랫폼 개발을 위한 디자인 패턴

- **전략 및 템플릿**
  이 두 가지는 브라우저와 코드를 공유할 때 가장 유용한 패턴일 것이다.  
  이들의 의도는 알고리즘의 공통 단계를 정의하여 일부 부분을 교체할 수 있도록 하는 것이다.  
  크로스 플랫폼 개발에서 이러한 패턴을 사용하면 컴포넌트의 플랫폼에 구애받지 않는 부분을 공유할 수 있으며, 다른 전략 또는 템플릿 방법(코드 분기(실행 시 혹은 빌드 시) 또는 모듈 교환을 사용하여 변경할 수 있음)을 사용하여 플랫폼에 따른 부분을 변경할 수 있다.
- **어댑터**
  전체 컴포넌트를 교체해야 할 때 유용할 것이다.  
  서버 애플리케이션이 SQLite와 같은 데이터베이스를 사용하는 경우 어댑터 패턴을 사용하여 브라우저에서 작동하는 데이터 저장소를 대체하는 구현을 제공할 수 있다.
- **프록시**
  서버에서 실행되는 코드가 브라우저에서 실행될 때 브라우저에서도 사용할 수 있도록 서버에서 사용되는 기능이 필요한 경우가 많다. 이 경우 원격 프록시 패턴이 유용할 수 있다.  
  브라우저에서 서버의 파일 시스템에 액세스하고 싶다면 Ajax 또는 WebSocket으로 명령과 반환값을 교환하는 방법을 사용하여 클라이언트의 fs 객체가 모든 요청을 프록시하여 서버에 존재하는 fs로 명령을 전달하고 결과값을 받도록 할 수 있다.
- **종속성 주입 및 서비스 로케이터**
  모듈이 주입되는 순간의 구현을 대체하는 데 유용할 수 있다.  
  모듈맵의 패킹에서 모듈 번들러가 서비스 로케이터 패턴을 사용하여 다른 모듈의 모든 코드를 하나의 파일로 조합한다.
